<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title> CS 417 Documents </title>
<link href="../../../css/layout.css" rel="stylesheet" type="text/css" />
<link href="../../../css/main.css" rel="stylesheet" type="text/css" />
<link href="../../../css/print.css" rel="stylesheet" type="text/css" media="print" />
<link href="../../../css/main-print.css" rel="stylesheet" type="text/css" media="print" />
<style type="text/css">

#main table.doclist {
	width: 80%;
}
#main .doclist .date, #main .doclist .item {
        vertical-align: baseline; /* for opera */
}
#main .doclist tr {
        vertical-align: baseline;
}
#main .doclist th.item {
        text-align: left;
}
#main .doclist td.item {
        text-align: left;
}
#main a.linksign:link, #main a.linksign:visited, #main a.linksign a:hover {
        text-decoration: none;
}

</style>
</head>
<body id="s_ru417">
<div id="wrapper">
<!-- _______________________________________ BANNER _______________________________________ -->
<div id="banner">
  <div id="logo">
  <img src="../../../css/images/pk-org-pencil.png" alt="pk.org" name="logo" width="122" height="45"/>
  </div>
  <div id="title"> Distributed Systems </div>
  <div id="search">
  <form method="get" action="http://www.google.com/search">
	<div style="border:none ;padding:2px;width:25em;">
	<input type="text" name="q" size="25" maxlength="255" value="" />
	<input type="submit" value="Search" />
	<input type="hidden"  name="sitesearch" value="www.pk.org" checked />
	</div>
  </form>
  </div>
  <ul>
    <li class="separator"><a href="../../../about/index.html">About</a></li>
    <li class="separator"><a href="../../../about/contact.html">Contact</a></li>
    <li><a href="../../../sitemap.html">Site map</a></li>
  </ul>
</div>

<!-- _______________________________________ MAIN NAV _______________________________________ -->
<div id="navbar">
	<ul>
	<li class="homelink"><a href="../../../index.html">Home</a></li>
<!--
	<li class="aboutlink"><a href="../../../about/index.html">About</a></li>
-->
	<li class="ru"><a href="../../../rutgers/index.html">Rutgers</a></li>
	<li class="ru352"><a href="../../../352/index.html">Internet Technology [352]</a></li>
	<li class="ru416"><a href="../../../416/index.html">Operating Systems [416]</a></li>
	<li class="ru417"><a href="../../../417/index.html">Distributed Systems [417]</a></li>
	<li class="ru419"><a href="../../../419/index.html">Computer Security [419]</a></li>
	<li class="cslink"><a href="../../../cs/index.html">Computing</a></li>
	<li class="photolink"><a href="../../../photo/index.html">Photography</a></li>
<!--
	<li class="funlink"><a href="#">Coming</a></li>
	<li class="funlink"><a href="#">Soon</a></li>
-->
	</ul>
</div>

<div id="subnav">
<p>
You are in: 
<ul>
	<li class="first"> <a href="index.html"> Home </a> 
 	<li> <a href="../../../index.html"> Rutgers </a> 
 	<li> <a href="../../index.html"> CS 417 </a> 
 	<li> <a href="../../notes/index.html"> Documents </a> 
 	<li> <a href="../../notes/make/index.html"> Sockets Tutorial </a> 
</ul>
</p>
</div>
<div id="content-wrapper">
<div id="main">
<div id="headline">
<h1> Introduction to Sockets Programming </h1>
</div>

<h1> Introduction </h1>
<p>
A <em>socket</em> is the mechanism that most popular operating systems provide to 
give programs access to the network. It allows messages to be sent and received
between applications (unrelated processes) on different networked machines.
</p>
<p>
</p>
<p>
The sockets mechanism has been created to be independent of any specific
type of network. IP, however, is by far the most dominant network and the most
popular use of sockets.
This tutorial provides an introduction to using sockets over the IP network (IPv4).
It starts with sockets over TCP/IP. If you're interested in jumping straight
to UDP/IP, go <a href="udp.html">here</a>.
</p>
<p>
This tutorial will not attempt to cover the entire topic of sockets.
There are tutorials on the web that delve into far greater
detail. On-line manual pages will provide you
with the latest information on acceptable parameters and functions.
The interface described here is the system call interface provided
by the OS X, Linux, and Solaris operating systems and is generally
similar amongst all Unix/POSIX systems (as well as many other operating
systems).
</p>

<h1> Programming with TCP/IP sockets </h1>
<p>
There are a few steps involved in using sockets:
</p>
<ol>
<li> Create the socket
<li> Identify the socket
<li> On the server, wait for an incoming connection
<li> On the client, connect to the server's socket
<li> Send and receive messages
<li> Close the socket
</ol>

<h2> Step 1. Create a socket </h2>
<p>
A socket, <code>s</code>, is created with the <em>socket</em> system call:
</p>
<div class="codeblock">
		int s = socket(domain, type, protocol)
</div>
<p>
All the parameters as well as the return value are integers:
</p>

<dl>
<dt> domain, or address family — </dd>
<dd> communication domain in which the socket should be created.
Some of address families are AF_INET (IP),
AF_INET6 (IPv6),
AF_UNIX (local channel, similar to pipes),
AF_ISO (ISO protocols), and
AF_NS (Xerox Network Systems protocols).
</dt>

<dt> type — </dt>
<dd>
type of service. This is selected according to the properties required by the application: SOCK_STREAM (virtual circuit service), SOCK_DGRAM (datagram service), SOCK_RAW (direct IP service). Check with your address family to see whether a particular service is available.
</dd>

<dt> protocol — </dt>
<dd>
indicate a specific protocol to use in supporting the sockets operation. This is useful in cases where some families may have more than one protocol to support a given type of service.
The return value is a file descriptor (a small integer).  The analogy of creating a socket is that of requesting a telephone line from the phone company.
</dd>
</dl>
<p>
For TCP/IP sockets, we want to specify the IP address family (AF_INET)
and virtual circuit service (SOCK_STREAM). Since there's only one
form of virtual circuit service, there are no variations of the
protocol, so the last argument, <em>protocol</em>, is zero. Our
code for creating a TCP socket looks like this:
</p>

<div class="codeblock-box">
#include &lt;sys/socket.h&gt;

...

if ((fd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0) {
	perror("cannot create socket");
	return 0;
}
</div>
&rArr; <a href="demo-01.html">Download a demo file</a> 

<h2> Step 2. Indentify (name) a socket </h2>
<p>
When we talk about <em>naming</em> a socket, we are talking about assigning a
transport address to the socket (a port number in IP networking).
In sockets, this operation is called binding an address and the <em>bind</em>
system call is used for this.
The analogy is that of assigning a phone number to the
line that you requested from the phone company in step 1 or that
of assigning an address to a mailbox.
</p>
<p>
The transport address is defined in a socket address structure.
Because sockets were designed to work with various different 
types of communication interfaces, the interface 
is very general. Instead of accepting, say, a port number as a
parameter, it takes a <code>sockaddr</code> structure whose actual
format is determined on the address family (type of network) you're
using. For example, if you're using UNIX domain sockets, <em>bind</em>
actually creates a file in the file system.
</p>
<p>
The system call for <em>bind</em> is:
</p>
<div class="codeblock">
	#include &lt;sys/socket.h&gt;

	int
	bind(int socket, const struct sockaddr *address, socklen_t address_len);
</div>
<p>
The first parameter, <code>socket</code>, is the socket that was created
with the <em>socket</em> system call.
</p>
<p>
For the second parameter, 
the structure <code>sockaddr</code> is a generic container that just allows
the OS to be able to read the first couple of bytes that identify the
address family.
The address family determines what variant of the <code>sockaddr</code>
struct to use that contains elements that make sense for that specific
communication type. For IP networking, we use <code>struct sockaddr_in</code>, which
is defined in the header <code>netinet/in.h</code>. This structure defines:
</p>

<div class="codeblock">
struct sockaddr_in {
        __uint8_t       sin_len;
        sa_family_t     sin_family;
        in_port_t       sin_port;
        struct  in_addr sin_addr;
        char            sin_zero[8];
};
</div>

<p>
Before calling <em>bind</em>, we need to fill out this structure. 
The three key parts we need to set are:
<dl>
<dt> sin_family </dt>
<dd> The address family we used when we set up the socket. In our case, it's AF_INET.
</dd>

<dt> sin_port </dt>
<dd>
The port number (the transport address).
You can explicitly assign a transport address (port) or allow the
operating system to assign one. If you're a client and won't be receiving
incoming connections, you'll usually just let the operating system pick
any available port number by specifying port 0.
If you're a server, you'll generally
pick a specific number since clients will need to know a port number
to connect to.
</dd>

<dt> sin_addr </dt>
<dd>
The address for this socket. This is just your machine's IP address. With
IP, your machine will have one IP address for each network interface. For
example, if your machine has both Wi-Fi and ethernet connections, that machine
will have two addresses, one for each interface. Most of the time, we don't
care to specify a specific interface and can let the operating system
use whatever it wants. The special address for this is 0.0.0.0, defined
by the symbolic constant <code>INADDR_ANY</code>.
</dd>
</dl>

<p>
Since the address structure may differ based on the type of transport used, the
third parameter specifies the length of that structure. This is simply
<code>sizeof(struct sockaddr_in)</code>.
</p>

<p>
The code to bind a socket looks like this:
</p>

<div class="codeblock-box">
#include &lt;sys/socket.h&gt;

...

struct sockaddr_in myaddr;

/* bind to an arbitrary return address */
/* because this is the client side, we don't care about the address */
/* since no application will connect here: */
/* INADDR_ANY is the IP address and 0 is the socket */
/* htonl converts a long integer (e.g. address) to a network representation */
/* htons converts a short integer (e.g. port) to a network representation */

memset((char *)&myaddr, 0, sizeof(myaddr));
myaddr.sin_family = AF_INET;
myaddr.sin_addr.s_addr = htonl(INADDR_ANY);
myaddr.sin_port = htons(0);

if (bind(fd, (struct sockaddr *)&myaddr, sizeof(myaddr)) < 0) {
	perror("bind failed");
	return 0;
}
</div>
&rArr; <a href="demo-02.html">Download a demo file</a> 

<h3> Note: number conversions (<em>htonl</em>, <em>htons</em>, <em>ntohl</em>, <em>ntohs</em>) </h3>
<p>
You might have noticed the <em>htonl</em> and <em>htons</em> references
in the previous code block. These convert four-byte and two-byte numbers
into network representations. Integers are stored in memory and sent
across the network as sequences of bytes.
There are two common ways of storing these bytes:
<em>big endian</em> and <em>little endian</em> notation. 
Little endian representation stores the least-significant bytes in low memory.
Big endian representation stores the least-significant bytes in high memory.
The Intel x86 family uses the little endian format. Old Motorola processors
and the PowerPC (used by Macs before their switch to the Intel architecture)
use the big endian format.
</p>
<p>
Internet headers standardized on using the big endian format. 
If you're on an Intel processor and set the value of a port to 
1,234 (hex equivalent <code>04d2</code>),
it will be be stored in memory as <code>d204</code>. 
If it's stored in this order in a TCP/IP header, however, <code>d2</code>
will be treated as the most significant byte and the network protocols
would read this value as 53,764.
</p>
<p>
To keep code portable &ndash; and to keep you from having to write
code to swap bytes and worry about this &ndash a few convenience macros
have been defined:
</p>
<dl>
<dt> htons </dt>
<dd> <em> host to network short </em>: convert a number into a
16-bit network representation. This is commonly used to store a port
number into a <code>sockaddr</code> structure.
</dd>

<dt> htonl </dt>
<dd> <em> host to network long </em>: convert a number into a
32-bit network representation. This is commonly used to store an IP 
address into a <code>sockaddr</code> structure.
</dd>

<dt> ntohs </dt>
<dd> <em> network to host short </em>: convert a 16-bit number from
a network representation into the local processor's format.
This is commonly used to read a port number from a
<code>sockaddr</code> structure.
</dd>

<dt> ntohl </dt>
<dd> <em> network to host long </em>: convert a 32-bit number from
a network representation into the local processor's format.
This is commonly used to read an IP address from a
<code>sockaddr</code> structure.
</dd>
</dl>

<p>
For processors that use the big endian format, these macros do absolutely
nothing. For those that use the little endian format (most processors, these days),
the macros flip the sequence of either four or two bytes. In the above code, writing
<code>htonl(INADDR_ANY)</code> and <code>htons(0)</code> is somewhat
pointless since all the bytes are zero anyway but it's good practice
to remember to do this at all times when reading or writing network data.
</p>

<h2> Step 3a. Connect to a server from a client</h2>
<p>
If we're a client process, we need to establish a connection to the server.
Now that we have a socket that knows where it's coming <em>from</em>, we need to
tell it where it's going <em>to</em>. The <em>connect</em> system call accomplishes this.
</p>
<div class="codeblock">
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int
connect(int socket, const struct sockaddr *address, socklen_t address_len);
</div>

<p>
The first parameter, <code>socket</code>, is the socket that was
created with the <em>socket</em> system call and named via <em>bind</em>.
The second parameter identifies the <em>remote</em>transport address</em>
using the same <code>sockaddr_in</code> structure that we used in <em>bind</em>
to identify our local address. As with <em>bind</em>, the third parameter
is simply the length of the structure in the second parameter: 
<code>sizeof(struct sockaddr_in)</code>.
</p>

<p>
The server's address will contain the IP address of the server machine as well
as the port number that corresponds to a socket listening on that port on that machine.
The IP address is a four-byte (32 bit) value in network byte order (see <em>htonl</em> above).
</p>

<p>
In most cases, you'll know the name of the machine but not its IP address.
An easy way of getting the IP address is with the <em>gethostbyname</em> library (libc) function.
<em>Gethostbyname</em> accepts a host name as a parameter and returns a <code>hostent</code>
structure:
</p>
<div class="codeblock">
struct  hostent {
	char    *h_name;        /* official name of host */
	char    **h_aliases;    /* alias list */
	int     h_addrtype;     /* host address type */
	int     h_length;       /* length of address */
	char    **h_addr_list;  /* list of addresses from name server */
};
</div>
<p>
If all goes well, the <code>h_addr_list</code> will contain a list of IP addresses. There
may be more than one IP addresses for a host. In practice, you should be able to use any
of the addresses or you may want to pick one that matches a particular subnet. You
may want to check that <code>(h_addrtype == AF_INET)</code> and <code>(h_length == 4)</code>
to ensure that you have a 32-bit IPv4 address.
We'll be lazy here and just use the first address in the list.
</p>
<p>
For example, suppose you want to find the addresses for google.com. The code will look like
this:
</p>
<div class="codeblock-box">
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;netdb.h&gt;

/* paddr: print the IP address in a standard decimal dotted format */
void
paddr(unsigned char *a)
{
        printf("%d.%d.%d.%d\n", a[0], a[1], a[2], a[3]);
}

main(int argc, char **argv) {
        struct hostent *hp;
        char *host = "google.com";
        int i;

        hp = gethostbyname(host);
        if (!hp) {
                fprintf(stderr, "could not obtain address of %s\n", host);
                return 0;
        }
        for (i=0; hp-&gt;h_addr_list[i] != 0; i++)
                paddr((unsigned char*) hp-&gt;h_addr_list[i]);
        exit(0);
}
</div>

<p>
Here's the code for establishing a connection to the address of a machine in <code>host</code>.
The variable <code>fd</code> is the socket which was created with the <em>socket</em>
system call.
</p>

<div class="codeblock-box">
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;stdio.h&gt;	/* for fprintf */
#include &lt;string.h&gt;	/* for memcpy */

struct hostent *hp;     /* host information */
struct sockaddr_in servaddr;    /* server address */

/* fill in the server's address and data */
memset((char*)&servaddr, 0, sizeof(servaddr));
servaddr.sin_family = AF_INET;
servaddr.sin_port = htons(port);

/* look up the address of the server given its name */
hp = gethostbyname(host);
if (!hp) {
	fprintf(stderr, "could not obtain address of %s\n", host);
	return 0;
}

/* put the host's address into the server address structure */
memcpy((void *)&servaddr.sin_addr, hp->h_addr_list[0], hp->h_length);

/* connect to server */
if (connect(fd, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0) {
	perror("connect failed");
	return 0;
}
</div>



<h2> Step 3b. Accept connections on the server </h2>
<p>
Before a client can connect to a server, the server should have a socket that
is prepared to accept the connections.

The <em>listen</em> system call tells a socket that it should be capable of
accepting incoming connections:
</p>
<div class="codeblock">
#include &lt;sys/socket.h&gt;

int
listen(int socket, int backlog);
</div>

<p>
The second parameter, <em>backlog</em>, defines the maximum number of pending connections
that can be queued up before connections are refused.
</p>

<p>
The <em>accept</em> system call grabs the first connection request on the
queue of pending connections (set up in <em>listen</em>) and
creates a new socket for that connection. The original socket that was set up
for listening is used <em>only</em> for accepting connections, not for exchanging data.

By default, socket operations are synchronous, or blocking, and accept
will block until a connection is present on the queue. The syntax of accept is:
</p>
<div class="codeblock">
#include &lt;sys/socket.h&gt;

int
accept(int socket, struct sockaddr *restrict address,
       socklen_t *restrict address_len);
</div>

<p>
The first parameter, <em>socket</em>, is the socket that was set for accepting
connections with <em>listen</em>.

The second parameter, <em>address</em>, is the address structure that gets filed
in with the address of the client that is doing the <em>connect</em>. This allows
us to examine the address and port number of the connecting socket if we want to.
The third parameter is filled in with the length of the address structure.
</p>

<p>
Let's examine a simple server. We'll create a socket, bind it to any available
IP address on the machine but to a specific port number. Then we'll set the
socket up for listening and loop, accepting connections.
</p>


<div class="codeblock-box">
#include &lt;sys/types.h&gt;

...
{
	int port = 1234;	/* port number */
	int rqst;       /* socket accepting the request */
	socklen_t alen;       /* length of address structure */
	struct sockaddr_in my_addr;    /* address of this service */
	struct sockaddr_in client_addr;  /* client's address */
	int sockoptval = 1;


	/* create a TCP/IP socket */
	if ((svc = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0) {
		perror("cannot create socket");
		exit(1);
	}

	<b>/* allow immediate reuse of the port */
	setsockopt(svc, SOL_SOCKET, SO_REUSEADDR, &sockoptval, sizeof(int));</b>

	/* bind the socket to our source address */
	memset((char*)&my_addr, 0, sizeof(my_addr));  /* 0 out the structure */
	my_addr.sin_family = AF_INET;   /* address family */
	my_addr.sin_port = htons(port);
	my_addr.sin_addr.s_addr = htonl(INADDR_ANY);
	if (bind(svc, (struct sockaddr *)&my_addr, sizeof(my_addr)) < 0) {
		perror("bind failed");
		exit(1);
	}

	/* set the socket for listening (queue backlog of 5) */
	if (listen(svc, 5) &lt; 0) {
		perror("listen failed");
		exit(1);
	}

	/* loop, accepting connection requests */
	for (;;) {
		while ((rqst = accept(svc, (struct sockaddr *)&client_addr, &alen)) &lt; 0) {
			<b>/* we may break out of accept if the system call */
                        /* was interrupted. In this case, loop back and */
                        /* try again */
                        if ((errno != ECHILD) && (errno != ERESTART) && (errno != EINTR)) {
                                perror("accept failed");
                                exit(1);
                        } </b>
                }
		/* the socket for this accepted connection is rqst */
		...
	}
}
</div>

&rArr; <a href="demo-03.html">Download a demo file</a> 
<p>
This code contains two special operations, marked in bold:
</p>
<dl>
<dt> 1. <code>setsockopt(svc, SOL_SOCKET, SO_REUSEADDR, &sockoptval, sizeof(int))</code></dt>
<dd> The <em>setsockopt</em> system call allows us to set special options on a
socket. In this case, we use <em>setsockopt</em> to set <code>SO_REUSEADDR</code>.
This allows us to reuse the port immediately as soon as the service exits. 
Some operating systems will not allow immediate reuse 
on the chance that some packets may still be en route to the port. 
Allowing us to reuse the port immediately is a huge help when debugging requires
us to start and restart the server over and over again.
</dd>

<dt> 2. <code>if ((errno != ECHILD) && (errno != ERESTART) && (errno != EINTR))</code></dt>
<dd> <em>accept</em> is a blocking system call that returns when an incoming connection
has been received. However, on some operating systems it may return if other signals
have been received, such as a death of a child process (<code>ECHILD</code>), 
an interrupted system call that should be restarted (<code>ERESTART</code>), 
or just an interrupted system call (<code>EINTR</code>). If any of these signals have
been received then we loop back and continue waiting for a connection. Otherwise we
print an error message and exit.
</dd>
</dl>

<h2> Step 4. Communicate </h2>
<p>
We <em>finally</em> have connected sockets between a client and a server! Communication is
the easy part. The same <em>read</em> and <em>write</em> system calls that work on files
also work on sockets. We can send 20 bytes from the client to server with:

</p>
<div class="codeblock">
	char buffer[MAXBUF];
	...
	nbytes = write(fd, buffer, 20); /* write 20 bytes in buffer */
</div>
<p>
We can read a bunch of data from the client with:
</p>
<div class="codeblock">
	char buffer[MAXBUF];
	...
	nbytes = read(fd, buffer, MAXBUF); /* read up to MAXBUF bytes */
</div>
<p>
One important thing to keep in mind is that TCP/IP sockets give you a byte stream, not
a packet stream. If you write 20 bytes to a socket, the other side is not guaranteed
to read 20 bytes in a <em>read</em> operation. It may read 20. It may read less if there
was packet fragmentation. In that case, you'll need to loop back and keep reading.
If you write 20 bytes to a socket and then write another 20 bytes to a socket, the
other side may read all 40 bytes at once ... or not.
</p>
<p>
If the amount of data you want to read matters then it's up to you to create a protocol
that lets you know what to read, such as sending a length count prior to sending data.
</p>


<p>
There are a few additional system calls that can be used for sending 
and receiving data on a socket.
We can ignore them most of the time but should know they exist for the times we
may need them.
All of these functions support an extra <em>flags</em> parameter.
The actual capabilities may differ among different
operating systems, so check the documentation on a specific system.
Some features that are supported are quality of service control, 
out-of-band data transmission, the ability to peek before reading incoming
data abd and the ability to bypass routing (mostly for debugging).
</p>

<p>
The <em>send</em> and <em>recv</em> calls are similar
to <em>read</em> and <em>write</em> with the addition of the <em>flags</em>
parameter.
</p>

<p>
The <em>sendto</em> and <em>recvfrom</em>
system calls are like <em>send</em> and <em>recv</em> but also allow callers to specify
or receive addresses of the peer with whom they are communicating. This is
most useful for connectionless sockets.
</p>

<p>
Finally, <em>sendmsg</em> and <em>recvmsg</em> allow one to use 
a <code>msghdr</code> structure. This reduces the number of
parameters and, most importantly, supports scatter/gather I/O.
Scatter/gather I/O 
allows one to minimize the numbner of system
calls by reading or writing from/to a number of distinct
memory blocks. This is common in cases where you might have a protocol
header sitting in one memory buffer and other data in another and 
both need to be sent as a message. Instead of calling <em>write</em>
on each memory region individually, we can use <em>sendmsg</em> to 
transmit both blocks of memory. 
</p>
<p>
Could this have been designed cleaner and simpler? Probably.
The  <em>read</em>/<em>write</em> or <em>send</em>/<em>recv</em> calls
are designed be used primarily for connection-oriented communication while
sendto/recvfrom or sendmsg/recvmsg are normally used for connectionless communication
since they allow one to specify the address.
</p>

<h2> Step 4a. Wait! What about printf? </h2>
<p>
If you want to use formatted I/O functions such as <em>fprintf</em> and <em>fscanf</em>,
you can. Just remember that a TCP socket looks and feels like a file descriptor.
Functions such as <em>fprintf</em> and <em>fscanf</em> are library functions
(not system calls) that are part of the Standard C
library (or the Standard I/O library on some systems). They add an extra layer of 
buffer management and open files are identified via FILE pointers (pointers to 
a FILE structure rather than file descriptors, which are small integers). If
you already have an open file, such as a connected socket, you can use functions such as
<em>fprintf</em>, 
<em>fscanf</em>, 
<em>fread</em>, 
<em>fwrite</em>, 
<em>fgets</em>, and
<em>fgetc</em> by calling the <em>fdopen</em> function and giving it your
already-open socket. The function will allocate the necesary FILE structure and
buffers. For example:
</p>
<div class="codeblock">
FILE *f;
f = fdopen(fd, "rw");
fprintf(f, "hellow, world\n");	/* write to the socket */
</div>


<h2> Step 5. Close the connection </h2>
<p>
When we're done communicating, the easiest thing to do is to close a socket with
the <em>close</em> system call &mdash; the same <em>close</em> that is used for files.
</p>
<p>
There's another way to close connections: the <em>shutdonw</em> system call.
</p>
<div class="codeblock">
#include &lt;sys/socket.h&gt;

int
shutdown(int socket, int how);
</div>

<p>
The second parameter, <em>how</em>, allows us to tell the socket what part of the
full-duplex connection to shut down:
<ul>
<li> A value of <code>SHUT_RD</code> will disallow further receives on that socket. </li>
<li> A value of <code>SHUT_WR</code> will disallow further sends on that socket. </li>
<li> A value of <code>SHUT_RDWR</code> will disallow both further sends and receives on that socket. </li>
</ul>
Closing a socket with <code>close(s)</code> is identical to using <code>shutdown(s, SHUT_RDWR)</code>.
</p>


<h2> Synchronous or Asynchronous? </h2>
<p>
Network communication (or file system access in general) system
calls may operate in two modes: synchronous or asynchronous. In the
synchronous mode, socket routines return only when the operation
is complete. For example, <em>accept</em> returns only when a connection
arrives. In the asynchronous mode, socket routines return immediately:
system calls become non-blocking calls (e.g., <em>read</em> does not block, waiting
until data arrives).
You can change the mode with the fcntl system call. For example,
</p>
<div class="codeblock">
	fcntl(s, F_SETFF, FNDELAY);
</div>
<p>
sets the socket <code>s</code></code> to operate in asynchronous mode.
</p>


</div>
<div id="footer">
<hr/>
<style type="text/css">  
span.codedirection { unicode-bidi:bidi-override; direction: rtl; }  
</style>  

<p> &copy; 2003-2019 Paul Krzyzanowski. All rights reserved.</p>
<p>For questions or comments about this site, contact Paul Krzyzanowski, 
<span class="codedirection">gro.kp@ofnibew</span>
</p>
<p>
The entire contents of this site are protected by copyright under national and international law.
No part of this site may be copied, reproduced, stored in a retrieval system, or transmitted, in any form,
or by any means whether electronic, mechanical or otherwise without the prior written
consent of the copyright holder.
If there is something on this page that you want to use, please let me know.
</p>
<p>
Any opinions expressed on this page do not necessarily reflect the opinions of my employers and may not
even reflect my own.
</p>
<p> Last updated: February 14, 2019
</p>
<img class="stamp" src="../../..//css/images/recycled_pixels_logo.png" alt="recycled pixels" height="80" width="80" />
</div> <!-- footer -->
<div id="tear">
</div>


<div id="sidebar1">
<h1 class="first">Contents </h1>
	<h2> CS 417 </h2>
	<ul>
	<li> <a href="../../index.html"> Main course page </a> </li>
	<li> <a href="../../news.html"> News </a> </li>
	<li> <a href="../../syllabus.html"> Syllabus </a> </li>
	<li> <a href="../../hw/index.html"> Homework </a> </li>
	<li> <a href="../../notes/index.html"> Documents </a> </li>
	<li> <a href="../../exam/index.html"> Exam info </a> </li>
	<li> <a href="../../grades/index.html"> Check your grades </a> </li>
	<li> <a href="https://sakai.rutgers.edu/portal/site/9cbf3407-e64c-4dd9-b644-238d707b91b3"> Sakai </a> </li>
	</ul>

	<h2> CS 417 background </h2>
	<ul>
	<li> <a href="../../about.html"> About the course </a> </li>
	<li> <a href="../../prereq.html"> Prerequisites </a> </li>
	<li> <a href="../../things.html"> Things you need </a> </li>
	<li> <a href="../../policy.html"> Policy  </a> </li>
	</ul>

</div>

<div id="sidebar2">
<!--
<h1 class="first"> Free junk </h1>
<p>
This is some stuff I'm throwing away. Please send me mail if you want any of it:
</p>
<hr/>
<ul>
<li> 
</ul>
-->
</div>

</div>
</div>
</body>
</html>
