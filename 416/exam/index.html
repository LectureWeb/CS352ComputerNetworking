<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title> CS 416 Exam info </title>

<link href="../../css/layout.css" rel="stylesheet" type="text/css" />
<link href="../../css/main.css" rel="stylesheet" type="text/css" />
<link href="../../css/print.css" rel="stylesheet" type="text/css" media="print" />
<link href="../../css/main-print.css" rel="stylesheet" type="text/css" media="print" />
<style type="text/css">
.rqbox {
	text-align: center;
	margin-left: auto;
	margin-right: auto;
        position: relative;
	width: 15em;
        background-color: #FDF5B6;
        border-style: double; border-width: 3px;
	border-radius: 10px;
        padding: 0.5em 0.5em 0.5em 0.5em;
}
</style>
</head>

<body id="s_ru416">
<div id="wrapper">
<!-- _______________________________________ BANNER _______________________________________ -->
<div id="banner">
  <div id="logo">
  <img src="../../css/images/pk-org-pencil.png" alt="pk.org" name="logo" width="122" height="45"/>
  </div>
  <div id="title"> Operating Systems </div>
  <div id="search">
  <form method="get" action="http://www.google.com/search">
	<div style="border:none ;padding:2px;width:25em;">
	<input type="text" name="q" size="25" maxlength="255" value="" />
	<input type="submit" value="Search" />
	<input type="hidden"  name="sitesearch" value="www.pk.org" checked />
	</div>
  </form>
  </div>
  <ul>
    <li class="separator"><a href="../../about/index.html">About</a></li>
    <li class="separator"><a href="../../about/contact.html">Contact</a></li>
    <li><a href="../../sitemap.html">Site map</a></li>
  </ul>
</div>

<!-- _______________________________________ MAIN NAV _______________________________________ -->
<div id="navbar">
	<ul>
	<li class="homelink"><a href="../../index.html">Home</a></li>
<!--
	<li class="aboutlink"><a href="../../about/index.html">About</a></li>
-->
	<li class="ru"><a href="../../rutgers/index.html">Rutgers</a></li>
	<li class="ru352"><a href="../../352/index.html">Internet Technology [352]</a></li>
	<li class="ru416"><a href="../../416/index.html">Operating Systems [416]</a></li>
	<li class="ru417"><a href="../../417/index.html">Distributed Systems [417]</a></li>
	<li class="ru419"><a href="../../419/index.html">Computer Security [419]</a></li>
	<li class="cslink"><a href="../../cs/index.html">Computing</a></li>
	<li class="photolink"><a href="../../photo/index.html">Photography</a></li>
<!--
	<li class="funlink"><a href="#">Coming</a></li>
	<li class="funlink"><a href="#">Soon</a></li>
-->
	</ul>
</div>

<div id="subnav">
<p>
You are in: 
</p>
<ul>
	<li class="first"> <a href="index.html"> Home </a> 
 	<li> <a href="../../rutgers/index.html"> Rutgers </a> 
 	<li> <a href="../index.html"> CS 416</a> 
 	<li> <a href="../exam/index.html"> Exam info </a> 
</ul>
</div>
<div id="content-wrapper">
<div id="main">
<div id="headline">
<h1> CS 416 Final Exam info </h1>
</div>

<div class="rqbox">
<a href="old/index.html">Get past 417 exams and information about exam taking</a>.
</div>

<h1> When & where </h1>
<p>
The final exam will be held on
Monday, May 11 from 8:00pm-10:00pm.
It will take place in our regular classroom,
<a href="http://rumaps.rutgers.edu/location/tillett-hall">TIL-257</a>.
</p>
<p>
If you plan to take the final, please be sure to bring your ID
with you.
</p>
<p>
Remember that the final is optional and will only serve to displace
a lower normalized grade on one of the three exams.
</p>

<!-- ------------------------------------------------------------ -->

<h1>
Exam rules
</h1>
<p>
Be sure to arrive on time. If you arrive after the exam starts,
you will not be allowed to take it.
</p>
<p>

</p>
<p>
This will be a closed book, closed notes exam.
Calculators, phones, laptops, and tablets
are neither needed nor permitted. If you have
these devices, you must turn them off, put them out
of sight, and not
access them for the duration of the exam.
</p>
<p>
No other electronic devices are permitted 
except for hearing aids, pacemakers,
electronic nerve stimulators, 
other implanted medical devices,
or electronic watches that function only as timekeeping devices
or chronographs.
</p>
<p>
<p>
Bring a couple of pens or pencils with you.
An extra pencil is affordable fault tolerance.
If you want to splurge, the <a href="http://amzn.com/B006YYPIUI/?tag=opk-20">Palomino Blackwing 602</a>
is considered by many to be one of the finest pencils available. 
</p>

<!--
<p>
The final exam will consist of 50 multiple choice questions covering topics from the entire
semester.
</p>
-->
<!-- ------------------------------------------------------------ -->

<h1> Past exams </h1>
<p>
<a href="old/index.html">Get past exams and information about exam taking here</a>.
</p>

<h1> What's on the exam? </h1>
<p>
You are responsible for <i>all</i> the material presented in class
except for the last lecture (which covered windowing and power
management).
The final is cumulative with a concentration toward the latter
half of the semester.
</p>
<p>
You might find it helpful to consult the past study guides:
</p>
<ul>
<li> <a href="study-guide-1.html">Study guide for exam 1</a> </li>
<li> <a href="study-guide-2.html">Study guide for exam 2</a> </li>
<li> <a href="study-guide-3.html">Study guide for exam 3</a> 
(with virtualization added) </li>
</ul>

<a name="list"></a><!--
<h1> Study Guide </h1>
<p>
The <a href="study-guide-final.html">study guide</a> is a concatanation of the previous
three study guides.
</p>
-->

<h1> Topics </h1>
<p>
You are responsible for the material from since the start of the semester.
</p>
<p>
Topics that you should know and may be on the exam include:
</p>

<h2> <a href="../lectures/l-intro.html">Introduction &amp; Booting </a> </h2>
<p>
	<strong>Text</strong>: chapter 1: 1.0-1.2 (p.3-12), 1.4-1.6 (p.18-25) 
</p>
<ul>
	<li> Some basic terms: multiprogramming, system call,
		batch systems, device drivers, preemption </li>
	<li> Operating system definition: what does it do?  </li>
	<li> Mechanism versus Policy </li>
</ul>

<h2> <a href="../lectures/l-intro.html"> Booting </a>  </h2>
<p>
	<strong>Text</strong>: 2.10 (p.92-93) 
</p>
<ul>
	<li> Boot loader: what does it do? </li>
	<li> Multi-stage boot loader (chain loading) </li>
	<li> You do not need to know the PC boot details but have a general
	idea of what the BIOS does (power-on test, initialize devices, identify boot device,
	and load MBR) </li>
	<li> You do not need to know the Mac's EFI-based boot sequence either </li>
	<li> Master Boot Record (MBR): just know that it contains a boot loader that then
	loads the Volume Boot Record (VBR) from a specific disk partition, which 
	contains the boot loader code that loads the operating system. </li>
	<li> You do not need to know how GRUB boots systems beyond the MBR containing
	the stage 1 loader that then loads the stage 2 loader, which then loads
	the oprating system (or gives you a choice). </li>
	<li> For EFI, jut know that it's a successor to the BIOS and has a built-in
	boot manager that usually loads an OS loader without going through a two-stage`process.
	</li>
</ul>

<h2> <a href="../lectures/l-processes.html">OS Concepts </a></h2>
<p>
	<strong>Text</strong>: 2.1-2.4 (p.55-73), 2.6.2 (p. 76), 2.7-2.7.5.3 (p.78-86) 
</p>

<ul>
	<li> Monolithic vs. modular vs. microkernel structures </li>
	<li> User mode vs. kernel mode (= privileged mode or supervisor mode) </li>
	<li> Getting from user to kernel mode and back again </li>
	<li> Traps (aka software interrupts): INT vs. SYSCALL instructions </li>
	<li> System calls </li>
	<li> Programmable interval timer interrupts: why do you need them? </li>
	<li> Mode switch and context switch </li>
	<li> What's invoved in saving process state? </li>
	<li> Device types: character, block, and network </li>
	<li> Interacting with devices:  memory mapped I/O </li>
	<li> Getting status from devices: interrupts and polling </li>
	<li> Moving data to/from devices: programmed I/O or DMA </li>
</ul>

<h2> <a href="../lectures/l-processes.html"> Processes </a> </h2>
<p>
	<strong>Text</strong>: 3.0-3.3.2  (p. p.105-122)
</p>
<ul>
	<li> Program vs. process </li>
	<li> Memory map: text, data, bss, heap, stack (don't memorize the list but know what each is) </li>
	<li> Process states: ready, running, blocked (aka waiting), zombie; transitions between states </li>
	<li> Preemptive multitasking </li>
	<li> Process control block (PCB): don't memorize the list of what it stores but
	know that it at least stores the machine state, process state, memory map, and process ID. </li>
	<li> Process list: keeps track of PCBs. </li>
	<li> Creating a process under Unix with fork: know that it creates a copy of the parent </li>
	<li> Know the difference between <em>fork</em>, <em>execve</em>, and <em>wait</em>.
	<li> What is a zombie process? </li>
	<li> Know how a process can tell if it is the parent or the child after a fork </li>
	<li> Loading and executing a program under Unix with execve: know that it overlays the data in the current process </li>
	<li> You do not need to memorize the internal sequence of operations that fork or other system calls perform </li>
	<li> The <em>init</em> process </li>
</ul>

<h2> <a href="../lectures/l-threads.html"> Threads </a></h2>
<p>
	<strong>Text</strong>: 4.0-4.6  (p.163-188)
</p>
<ul>
	<li> What's a thread vs. a process? </li>
	<li> What do threads in a process share? entire memory map, open files,
	permissions</li>
	<li> What's a thread control block (TCB)? </li>
	<li> Kernel-level versus user-level threads. Advantages &amp; disadvatages of each. </li>
	<li> Hybrid kernel/user models. </li>
	<li> thread create and join vs. fork/wait. </li>
	<li> Linux clone() operation vs. threads </li>
</ul>

<h2> <a href="../lectures/l-sync.html"> Synchronization </a> </h2>
<p>
	 <strong>Text</strong>: 5.0-5.9  (p.203-238), 5.11 (Deadlocks, p. 242-249)
</p>
<ul>
	<li> Definitions: concurrent, asynchronous, independent, synchronous </li>
	<li> What is a race condition? </li>
	<li> Definitions: critical section, mutual exclusion, deadlock, starvation </li>
	<li> What is a spinlock (aka busy waiting)? </li>
	<li> Problems with disabling interrupts. </li>
	<li> Problems with test and set locks in software </li>
	<li> You don't have to know Peterson's algorithm </li>
	<li> Test and set instruction: how does it work? </li>
	<li> compare and swap instruction: how does it work? </li>
	<li> fetch and increment instruction: how does it work? </li>
	<li> Avoiding spin locks - turn to OS </li>
	<li> Priority inversion </li>
	<li> Semaphores </li>
		<ul>
		<li> What is a semaphore? </li>
		<li> What are the operations on it? Understand initialization, <em>up</em>, and <em>down</em> </li>
		<li> When does a semaphore put threads to sleep and wake them up? </li>
		<li> Understand the producer-consumer example </li>
		</ul>
	<li> Event counters </li>
		<ul>
		<li> What are the operations on it? </li>
		<li> When does an event counter put a thread to sleep or wake it up? </li>
		</ul>
	<li> Condition variables (monitors)</li>
		<ul>
		<li> What are the operations in condition variables? </li>
		<li> When does a condition variable put a thread to sleep or wake it up? </li>
		</ul>
	<li> Messages</li>
		<ul>
		<li> Understand send and receive operations </li>
		<li> understand the producer-consumer example with null messages and a <em>read</em>
		causing a thread to block if there is nothing to read </li>
		<li> Understand rendezvous: reads and writes block </li>
		<li> Understand mailboxes and how indirect addressing helps to support
		multiple readers and writers </li>
		</ul>
	<li> Deadlock </li>
		<ul>
		<li> Conditions for deadlock </li>
		<li> Wait-for graph </li>
		<li> Ways of handling: prevention, avoidance, detection, ignore </li>
		</ul>
</ul>

<h2> <a href="../lectures/l-scheduling.html"> Process Scheduling </a></h2>
<p>
	<strong>Text</strong>: 6.0-6.5.4 (p. 259-291), 6.7-6.7.3  (p.298-307)
</p>

<ul>
	<li> CPU bursts and I/O bursts </li>
	<li> What does a scheduler do? </li>
	<li> When does a scheduler get a chance to dispatch (run) a process? </li>
	<li> Preemptive versus cooperative schedulers </li>
	<li> Turnaround time, response time, 
	<li> You don't have to memorize the list of 10 scheduling goals. </li>
	<li> First-come, first served scheduling </li>
		<ul>
		<li> What's the scheduling algorithm? </li>
		<li> Disadvantages </li>
		</ul>
	<li> Round-robin scheduling </li>
		<ul>
		<li> What's the scheduling algorithm? </li>
		<li> What is a quantum (aka time slice)? </li>
		<li> Pros and cons of big and small time slices </li>
		<li> What are the key advantages and disadvantages? </li>
		</ul>
	<li> Shortest remaining time first scheduling </li>
		<ul>
		<li> What's the scheduling algorithm? </li>
		<li> What is the main purpose/advantage? </li>
		<li> What is the main drawback? </li>
		<li> Estimating CPU burst time: don't memorize the function but 
		understand that it's a weighted exponential average that is a function
		of the last measured CPU burst and past history.
		</li>
		</ul>
	<li> Priority scheduling  </li>
		<ul>
		<li> What's the scheduling algorithm? </li>
		<li> What is the main purpose/advantage? </li>
		<li> What is the main drawback? </li>
		<li> Static vs. dynamic priorities </li>
		<li> What is starvation? </li>
		<li> What is process aging? </li>
		</ul>
	<li> Multilevel feedback queues  </li>
		<ul>
		<li> Difference from multilevel queues </li> 
		<li> Priority classes </li>
		<li> Understand how processes trickle to lower levels based on CPU burst </li>
		<li> Role of process aging </li>
		<li> Gaming the scheduler by performing I/O </li>
		<li> Advantages &amp; disadvantages </li>
		</ul>
	<li> Lottery scheduler </li>
		<ul>
		<li> Goal and general principle </li>
		</ul>

	<li> I will not ask you about guaranteed scheduling, or the completely fair scheduler </li>
	<li> I will not ask you about Linux,  Windows, or Solaris schedulers </li>
	<li> Multiprocessor scheduling issues: CPU affinity, hard vs. soft affinity</li>
	<li> What is hyperthreading? </li>
	<li> Purpose of Linux scheduling domains </li>
</ul>

<h2> <a href="../lectures/l-scheduling.html"> Real-time Scheduling </a></h2>
<p>
	<strong>Text</strong>: 6.6-6.6.4 (p. 291-297) 
</p>
<ul>
	<li> Definitions: release time, deadline, hard vs. soft deadlines </li>
	<li> Earliest deadline scheduling: how do you pick the next process? </li>
	<li> Least slack scheduling: how do you pick the next process? </li>
	<li> Comparison between earliest deadline and least slack scheduling </li>
	<li> Rate-monotonic analysis: how do you prioritize processes? </li>
</ul>


<h2> <a href="../lectures/l-memory.html"> Memory Management</a> </h2>
<p>
	<strong>Text</strong>: <em> chapter 7: Main Memory: 7.1 (Background) - 7.9 (Summary); pages 325-365 </em>
	<br/>
	<strong>Text</strong>: <em> chapter 8: Virtual Memory: 8.1 (Background) - 8.9.3 (TLB Reach), pages 371-416 </em>
</p>
<ul>
	<li> Static vs. dynamic linking, shared libraries </li>
	<li> Monoprogramming vs multiprogramming </li>
	<li> Single partition monoprogramming </li>
	<li> CPU utilization </li>
	<li> Dynamically relocatable code </li>
	<li> Memory management unit: concept of dynamic address translation</li>
	<li> Logical (virtual) vs Physical (real) addresses </li>
	<li> Base &amp; limit addressing </li>
	<li> Multiple fixed partitions (internal vs. external fragmentation) </li>
	<li> Variable partition multiprogramming </li>
	<li> Segmentation </li>
	<li> <span class="strike">Allocation algorithms: first fit, best fit, worst fit. </span></li>
	<li> Memory compaction (relocation to combine holes) </li>

	<li> Page-based virtual memory:
		<ul>
		<li> page number and offset (displacement) </li>
		<li> page table, PTE, page fault </li>
		<li> direct mapping paging system, page table base register </li>
		<li> Translation lookaside buffer (TLB) </li>
		<li> Hit ratio </li>
		<li> Address space identifier (ASID): why do you want it? </li>
		<li> Multilevel (hierarchical) page tables, partial page table: understand benefit </li>
		<li> I will not ask you about inverted page tables </li>
		</ul>
	</li>
	<li> Understand the benefits of page-based virtual memory </li>
	<li> Key points about the ARM MMU: 
		<ul>
		<li> pages (via a two-level hierarchy) and sections (via direct mapping) </li>
		<li> I will not ask you about ARM's two page tables per process  </li>
		<li> Two levels of TLB </li>
		<li> I will not ask you about the different translation flows. </li>
		<li> Do not memorize the sizes of different sections and pages.
		Just understand the value of sections in having an efficient way to map large
		chunks of memory, such as an operating system, to a process' address space. </li>
		</ul>
	</li>
	<li> Key points about the Intel MMU: 
		<ul>
		<li> Combined paging &amp; segmentation </li>
		<li> What's a <em>far pointer</em>? </li>
		<li> Segmentation, offering per-segment protection </li>
		<li> Depending on the address size and page size, anywhere from direct mapping to four levels of page tables </li>
		<li> <span class="strike">Two levels of TLB</a> </li>
		<li> I will not ask you about descriptor tables or the partitioning of an address to support multi-level page tables. </li>
		<li> I will not ask you about the different memory models that the architecture supports (IA-32 paging, 64-bit mode, PAE, etc.);
		just know that you have
		real mode (physical), paging, segmentation, or combined paging and segmentation. </li>
		</ul>
	</li>
	<li> Demand paging: understand know the concept </li>
	<li> Memory-mapped files </li>
	<li> Have a good idea of what the page fault handler does, not any specific steps </li>
	<li> Page replacement algorithms
		<ul>
		<li> FIFO replacement</li>
		<li> LRU replacement (why can't we use this?)  </li>
		<li> Not frequently used replacement </li>
		<li> Clock (second chance) replacement </li>
		<li> <span class="strike">N<sup>th</sup> chance replacement</span> </li>
		</ul>
	</li>
	<li> <span class="strike">Kernel swap daemon</span> </li>
	<li> Locality and the working set </li>
	<li> Working set model </li>
	<li> Thrashing </li>
	<li> Resident set </li>
	<li> Using page fault frequency to manage resident sets </li>
	<li> Kernel memory allocation
		<ul>
		<li> Page allocator (why might you need contiguous pages?) </li>
		<li> Buddy system </li>
		<li> I will not ask you about the zone allocator </li>
		<li> Slab allocator <em>(you don't need to know the structures or operations; just have an idea of how it works)</em></li>
		<li> SLOB allocator </li>
		<li> I will not ask you about SLUB; it's just a variation of Slab </li>
		</ul>
	</li>
</ul>

<h2> <a href="../lectures/l-devices.html"> Device drivers </a></h2>
<p>
	<br/> <strong>Text</strong>: <em> chapter 12: I/O Systems: 7.1 (Overview) - 7.9 (Transforming I/O Requests to Hardware Operations); pages 561-589 </em>
	<br/> <strong>Text</strong>: <em> Chapter 9: Mass-Storage Structure: 9.1.1 (Magnetic Disks), 9.1.2 (Solid State Disks), 9.4 (Disk Scheduling) - 9.5.1 (Disk Formatting); pages 441-443, 446-454 </em>
	457-459, 462-469 </em>
</p>
<ul>
	<li> Device driver, device controller </li>
	<li> Mechanism vs. policy </li>
	<li> Device independence </li>
	<li> Block devices </li>
	<li> Character devices (you don't have to know about raw and cooked modes) </li>
	<li> Network devices </li>
	<li> Kernel modules (you don't need to know the Linux commands; know that a module contains a function that the
kernel calls upon loading to allow it to initialize itself and register its services</li>
	<li> You don't need to know the cdev, gendisk, or net_device structures or their operations
	but know that each type of device has a set of common functions that drivers need to implement.
	<li> Buffer cache: understand buffered I/O. Why do you want it? </li>

	<li> Blocking, non-blocking, asynchronous I/O </li>
	<li> Major and minor numbers; devices in the filesystem namespace </li>
	<li> <em>I will not ask you about the Linux udev device manager or the netlink socket interface </em> </li>
	<li> <em>I will not ask you about any of the functions of file interface or driver interface </em> </li>
	<li> Kernel, user, and interrupt execution contexts </li>
	<li> interrupt handler: understand what a <em>hook</em> is </li>
	<li> Top half vs. bottom half interrupt servicing </li>
	<li> I/O queues, device status table </li>
	<li> Goal of driver frameworks (super high level - just that they identify classes of devices and define required functions) </li>
	<li> The disk
		<ul>
		<li> Disk scheduling algorithms: SCAN, LOOK, C-SCAN, C-LOOK, SSTF, FCFS</li>
		<li> <em>I will not ask you about Completely Fair Queueing </em> </li>
		<li> Linux deadline scheduling</li>
		<li> NOOP scheduling (FIFO): when would you use it? </li>
		<li> Anticipatory scheduling: know it's built on top of C-SCAN </li>
		<li> Read-ahead </li>
		<li> Logical block addressing vs. cylinder-head-sector addressing.
		</ul>
	</li>
</ul>

<h2> <a href="../lectures/l-filesystems.html"> File systems</a></h2>
<p>
	<br/> <strong>Text</strong>: <em> Chapter 10: File-System Interface: 10.1 (File Concept) - 10.3.5 (Tree-Structured Directories),
	10.4 (File-System Mounting); pages 477-496, 500-502 </em>
	<br/> <strong>Text</strong>: <em> Chapter 11: File-System Implementation: 11.1 (File-System Structure) - 11.7.2 (Log-Structured File Systems);
	pages 517-544</em>
</p>

	<ul>
	<li> Terms </li>
		<ul>
		<li> Disk</li>
		<li> Block</li>
		<li> Partition</li>
		<li> Volume</li>
		<li> Track</li>
		<li> Cylinder</li>
		<li> Seek</li>
		<li> File</li>
		<li> File name</li>
		<li> File data</li>
		<li> Metadata</li>
		<li> Attribute</li>
		<li> Directory</li>
		<li> Superblock</li>
		<li> inode</li>
		<li> Clusters vs. Extents </li>
		<li> Internal vs. external fragmentation </li>
		</ul>
	<li> Virtual File System (VFS)  </li>
		<ul>
		<li> Superblock: just know that it keeps key parameters about the file system: size, name, type </li>
		<li> inode: what kind of info does it store at the VFS layer? </li>
		<li> directory entry (dentry) </li>
		<li> file: don't memorize the file operations but a few of them should make sense</li>
		</ul>
	<li> mount points: kernel needs to keep a track of mounted file systems </li>
	<li> Implementing file systems  </li>
		<ul>
		<li> Allocation: 
			<ul>
			<li> contiguous </li>
			<li> extents </li>
			<li> linked allocation </li>
			<li> file allocation table (FAT)  </li>
			<li> indexed (inode); combined indexing with indirect blocks  </li>
			</ul>	
		</li>
		<li> Directories - possible structures: linear list, hash, B-Tree </li>
		<li> Hard links vs. symbolic links </li>
		<li> Functions: understand the basic operations; don't memorize steps
			<ul>
			<li> mounting</li>
			<li> union mounts</li>
			<li> file system checking (don't memorize steps but understand the point of it)</li>
			<li> steps in creating files (don't memorize but understand)</li>
			<li> creating directories: what's different from creating a file?</li>
			<li> opening a file</li>
			<li> writing to a file (don't memorize steps but understand what needs to be done if the file has to grow; also, realize that sometimes you need to read to modify just parts of a block)</li>
			<li> reading from a file</li>
			<li> deleting a file (understand that it's about reference counting)</li>
			</ul>
		</ul>
		<li> Case studies 
			<ul>
			<li> DOS/Windows FAT 
				<ul>
				<li> Understand that a directory is file containing names, attributes, and the starting block number. </li>
				<li> Understand how to use a file allocation table. </li>
				</ul>
			</li>
			<li> Unix File System (UFS) 
				<ul>
				<li> Understand that a directory is a file containing a list of {name, inode} pairs. </li>
				<li> Understand what inodes are and how disk blocks are mapped. </li>
				<li> understand the effects of disk fragmentation. </li>
				</ul>
			</li>
			<li> BSD Fast File System (FFS)
				<ul>
				<li> How did it improve over UFS? </li>
				<li> Large blocks, fragments (don't worry about the mechanics of how fragments are managed) </li>
				<li> Cylinder groups: how did they help? </li>
				<li> Prefetching blocks </li>
				<li> Remember that metadata writes are synchronous for robustness </li>
				</ul>
			</li>
			<li> Linux ext2 
				<ul>
				<li> Know that it's similar to FFS but cylinder groups are replaced with block groups </li>
				<li> Know that fragments are gone. </li>
				<li> Know that it's more aggressive with caching and not forcing metadata writes to be synchronous </li>
				</ul>
			</li>
			<li> Linux ext3 
				<ul>
				<li> Understand the concept of a journal, 
				consistent update problem </li>
				<li> redo logging </li>
				<li> ordered journaling as an optimization to data journaling </li>
				<li> writeback journaling vs. ordered journaling </li>
				</ul>
			</li>
			<li> Linux ext4 
				<ul>
				<li> Don't study the list of changes; just
				know that it uses extents instead of block numbers </li>
				</ul>
			</li> 
			<li> Microsoft NTFS 
				<ul>
				<li> know that it offers journaling + data compression </li>
				<li> know that it uses extents </li>
				<li> Know the MFT is similar to an inode (file record) table but is itself structured like a file </li>
				<li> Everything is a file: easy to grow the file system </li>
				<li> Behind-the-scenes compression of files </li>
				</ul>
			</li>
			</ul>

		</li>
	</li>
	</ul>
</li>


<h2> <a href="../lectures/l-specialfs.html"> File systems: Log-Structured File Systems</a></h2>
<p>
	<em>Warning: the description of log-structured file systems in the text (pages 543-544) is incorrect.
	It discusses journaling rather than log-structured file systems.
	</em>
</p>
<ul>
	<li> dynamic vs. static wear leveling </li>
	<li> Block Lookup Table: logical-to-physical block translation on the flash controller </li>
	<li> Flash Translation Layer (FTL): </li>
	<li> just the basics of a log-structured file system: all data, inode, and metadata changes are written as logs </li>
	<li> <em>I will not ask you about YAFFS2 vs. YAFFS1 or versus any other log-structured types </em> </li>
	<li> Know that for YAFFS the name space is reconstructed by traversing the log. </li>
	<li> Know that log entries that are no longer needed can get reused. </li>
	<li> Why is garbage collection needed? </li>
	<li> Purpose of checkpointing. </li>
	<li> Why is a log-structured file system good for wear leveling? </li>
</ul>

<h2> <a href="../lectures/l-specialfs.html"> Pseudo devices and special file systems</a></h2>
<p>
	<br/> <strong>Text</strong>: <em> Section 15.7.4: The Linux Process File System, pages 720-721</em>
</p>


<ul>
	<li> Pseudo devices: null device, zero device, random device </li>
	<li> Loop device: what is it? </li>
	<li> Special file systems </li>
	<ul>
		<li> Process file system (procfs): what does it do?</li>
		<li> Device file system (devfs): purpose </li>
		<li> FUSE (user-level file system) </li>
	</ul>
</ul>

<h2> <a href="../lectures/l-net.html"> Client-Server networking </a></h2>
<p>
</p>


<ul>
	<li> Recognize <em>channel partitioning</em>, <em>TDM</em>, <em>FDM</em>, and <em>token passing</em>
		if you see them but you do not have to know about them except that they differ from the
		<em>random access</em> used by packet switching.
	<li> circuit-switched vs. packet switched networks </li>
	<li> protocols and layering </li>
	<li> OSI reference model: understand layers 1-4 (physical, data link, network, transport) </li>
	<li> I will not ask about media, hubs, routers, bridges, ethernet topology, or wireless networks </li>

	<li> What is protocol (packet) encapsulation? </li>
	<li> transport-layer protocols: connection-oriented (virtual circuit) vs. connetionless (datagram) </li>
	<li> Internet Protocol (IP) </li>
		<ul>
		<li> Ethernet MAC address vs. IP address </li>
		<li> What is the <em>Address Resolution Protocol</em> (<em>ARP</em>) used for? </li>
		<li> What is the <em>Domain Name System</em> (<em>DNS</em>) used for? </li>
		<li> TCP vs. UDP </li>
		<li> Purpose of port numbers </li>
		</ul>
	<li> I will not ask about jumbo packets, MTUs, the structure of ethernet, IP, IPv6, TCP, or UDP packets.
		Understand, however, ethernet vs. IP addresses and that transport-layer IP protocols (TCP, UDP) have a port number. </li>
	<li> I will not ask about routing </li>
</ul>

<h2> <a href="../lectures/l-sockets.html"> Sockets </a></h2>

<p>
	<br/> <strong>Text</strong>: <em> 3.6 (Communication in Client-Server Systems): 3.6.1 (Sockets); pages 136-138 </em>
</p>

<ul>
	<li> Purpose of sockets </li>
	<li> What do the following system calls do? <em>socket</em>, <em>bind</em>, <em>listen</em>, <em>connect</em></li>
	<li> I will not ask you about the parameters of the above functions </li>
	<li> I will not ask about synchronous vs. asynchronous operations </li>
	<li> System call interfaces: file descriptor-based and socket-specific</li>
		<ul>
		<li> WHat does it mean for a socket to be compatible with files? </li>
		</ul>
	<li> What's the purpose of the the <code>socket</code> structure? </li>
	<li> What's the purpose of a socket buffer (<tt>sk_buff</tt>)? How does it make moving data through the network stack efficient? </li>
	<li>I will not ask you about the <tt>socket</tt> or <tt>proto</tt> structures but know what a socket structure is used for vs. a sk_buff (socket buffer).</li>
	<li> Top half vs. bottom half work for receiving incoming messages </li>
	<li> What's the purpose of the abstract device interface layer?</li>
	<li> I will not ask about routing. You don't need to know about the FIB (Forwarding Information Base). </li>
	<li>I will not ask about specific functions within the device interface (e.g., <em>dev_queue_xmit</em>, <em>netif_rx_schedule</em>)</li>
	<li>Understand where device drivers sit in the hierarchy.</li>
	<li>Linux NAPI approach to handling device interrupts </li>
</ul>


<h2> <a href="../lectures/l-rpc.html">Remote procedure calls</a>  </h2>

<p>
	<br/> <strong>Text</strong>: <em> 3.6 (Communication in Client-Server Systems): 3.6.2 (Remote Procedure Calls); pages 138-142 </em>
</p>

<ul>
	<li> Remote procedure call: definition/goal </li>
	<li> I will not ask you about the functional flow of regular procedure calls </li>
	<li> Language-level versus operating-system construct </li>
	<li> Stub functions: purpose of client and server stub functions </li>
	<li> RPC call flow: understand the diagram and what is meant by marshaling/unmarshaling </li>
	<li> I will not ask about big vs. little endian or data representation formats </li>
	<li> I will not ask about implicit vs. explicit typing, where to bind, transport protocols, or security issues </li>
	<li> Understand the purpose of an interface definition language (IDL) </li>
</ul>


<h2> <a href="../lectures/l-nfs.html">Network attached storage </a>  </h2>
<p>
	<br/> <strong>Text</strong>: <em> 11.8 (NFS) pages 545-551 </em>
</p>
<ul>
	<li> Network attached storage (NAS): definition </li>
	<li> upload/download model vs. remote access model </li>
	<li> sequential vs. session semantics </li>
	<li> I will not ask about immutable files, atomic transactions, or file usage patterns </li>
	<li> Understand stateful vs. stateless approaches </li>
	<li> understand what write-through caches, read-ahead, and delayed writes do </li>
	<li> NFS 
		<ul>
		<li> I will not ask about design goals </li>
		<li> Understand that an RPC interface is used </li>
		<li> Purpose of mounting vs. directory &amp; file access protocols </li>
		<li> What does the <em>lookup</em> RPC do and why is it not an <em>open</em> of a file? </li>
		<li> Do not memorize the NFS RPC functions but have an idea of what they do. </li>
		<li> Validation as an approach to cache management </li>
		<li> Read-ahead to improve performance </li>
		<li> Don't memorize the list of problems with NFS but go through them and understand them </li>
		<li> Why does locking not work? Why can open with append not be guaranteed to work? </li>
		</ul>
	</li>
	
	<li> AFS 
		<ul>
		<li> Design goals </li>
		<li> Big ideas: whole file serving and whole file caching </li>
		<li> I will not ask about cells, volumes, the cell directory server, or the Volume Location Database </li>
		<li> callback promise </li>
		<li> session semantics </li>
		</ul>
	</li>
	
	<li> SMB/CIFS 
		<ul>
		<li> Design goals </li>
		<li> message blocks  </li>
		<li> remote access protocol </li>
		<li> I will not ask about the structure of the message block </li>
		<li> Don't memorize the list of commands </li>
		<li> Understand the things you can do with SMB that you cannot do with NFS because SMB is stateful (delete on the server won't cause a remotely open file to disappear, lock a file, open with append: all these require state) </li>
		<li> I will not ask about the protocol but note that it's connection-oriented </li>
		</ul>
	</li>
</ul>


<h2> <a href="../lectures/l-protection.html">Protection  </a> </h2>
<p>
	<br/> <strong>Text</strong>: <em> 13 (Protection) - 13.3.2 (An Example: UNIX) pages 601-606. </em>
	<br/> <strong>Text</strong>: <em> 13.4 (Access Matrix) - 13.5.3 (Capability Lists) pages 608-613. </em>
	<br/> <strong>Text</strong>: <em> 13.6 (Access Control) - 13.7 (Revocation) pages 615-616. </em>
</p>

<ul>
	<li> Principle of least privilege </li>
	<li> Privilege separation </li>
	<li> setuid </li>
	<li> Protection domain, access matrix </li>
	<li> I will not ask about domain transfers, copy, owner, and control operations </li>
	<li> Access control list vs. capability list </li>
	<li> Limited ACLs in POSIX systems vs. full ACLs </li>
	<li> Discretionary access control (DAC) vs. mandatory access control (MAC) </li>
	<li> What does the Bell-LaPadula model do? </li>
</ul>


<h2> <a href="../lectures/l-crypto.html">Cryptographic systems </a> </h2>
<p>
	<br/> <strong>Text</strong>: <em> 14.4 (Cryptography as a Security Tool) - 14.4.1 (Encryption) pages 650-657. </em>
</p>

<ul>
	<li> restricted vs. symmetric vs. public key algorithms </li>
	<li> use of a hash function </li>
	<li> key length vs. difficulty of brute-force attack </li>
	<li> understand the difference between public key and symmetric algorithms;
		what private keys are used for, what public keys are used for. </li>
        <li> key exchange using public key cryptography </li>
	<li> how do you use public keys for encryption, signatures, and key exchange? </li>
	<li> do not memorize algorithms:
                        I will not ask you about the inner working of algorithms.
			You should understand, however, how to use public keys, private keys, and symmetric keys.
	</li>
	<li> hybrid cryptosystem (understand advantage and how session key exchange works) </li>
	<li> digital signatures with public key algorithms </li>
	<li> purpose of a cryptographic hash function </li>
	<li> secure communciation 
		<ul>
		<li> with symmetric cryptography </li>
		<li> with public key cryptography </li>
		<li> with a hybrid cryptosystem </li>
		</ul>
	</li>
</ul>


<h2> <a href="../lectures/l-auth.html">Authentication </a> </h2>
<p>
	<br/> <strong>Text</strong>: <em> 14.5 (User Authentication) - 14.7 (Firewalling) pages 661-674. </em>
</p>

<ul>
	<li> reusable passwords: PAP, password authentication protocol </li>
		<ul>
		<li> How do you ensure passwords cannot be not accessed? </li>
		<li> dictionary attacks, hash, salt </li>
		</li>
		</ul>
	<li> Challenge Handshake Authentication Protocol (CHAP) </li>
	<li> one-time passwords: SecurID (just know that the password is <em>f(PIN, seed, time)</em>)  </li>
	<li> Wgat us a man-in-the-middle attack? </li>

	<li> public key authentication 
		<ul>
		<li> how does it work? What is a nonce and how do you use it? </li>
		<li> digital certificates (don't memorize fields but understand how a certificate can be used) </li>
			<ul>
			<li> What's the purpose of a certificate? </li>
			<li> What's makes it unforgeable? </li>
			</ul>
		</ul>
	</li>
</ul>


<h2> <a href="../lectures/l-security.html">Security  </a> </h2>
<p>
	<br/> <strong>Text</strong>: <em> 14 (Security) - 13.3.3 (Denial of Service) pages 633-650. </em>
</p>

<ul>
	<li> I will not ask you to list threats, discuss attack categories or techniques </li>
	<li> Buffer overflow bug: stack smashing </li>
		<ul>
		<li> benefits of no execute permission </li>
		<li> Return Oriented Programming </li>
		<li> Address Space Layout Randomization (ASLR) </li>
		<li> Stack canaries </li>
		</ul>

	<li> I will not ask about network service penetration or SYN flooding </li>
	<li> I will not ask about key logging </li>
	<li> What's a virus?  </li>
	<li> What's a rootkit? </li>
	<li> sandboxing  </li>
		<ul>
		<li> chroot jail </li>
		<li> Kernel-level sandboxing: understand that it provides policy-based access control </li>
		<li> What is the Java sandbox? </li>
		</ul>
	<li> signed software </li>
		<ul> 
		<li> page-based signatures - why? </li>
		<li> vs. whole-code signatures (remember how signatures are created) </li>
		<li> I will not ask you any details about Microsoft Authenticode </li>
		</ul>
</ul>


<h2> <a href="../lectures/l-vm.html">Virtualization</a> </h2>

<ul>
	<li> Types of virtualization: memory, CPU, storage, machine </li>
	<li> Processor (CPU) virtualization vs. machine virtualization </li>
	<li> Virtual Machine Monitor, hypervisor </li>
	<li> how do  privileged instructions work under a MM? Trap into hypervisor. </li>
	<li> Hosted VM vs. Native VM </li>
	<li> Native VM architecture requires the VMM to do scheduling of the virtual machines under it </li>
	<li> You do not have to know the architectural support in Intel and AMD architectures
	but you should understand that they can create an exit from a VMM that allows software (the OS under
	the VM) to feel like an interrupt took place </li>
	<li> I will not ask you about scheduling VMs </li>
	<li> What is OS-level virtualization? </li>
</ul>




<!--
<p> Exam 1 topics </p>
<ul>

</ul>
<p> Exam 2 topics </p>
<ul>

</ul>
<p> Exam 3 topics (plus virtualization) </p>
<ul>
<li> <a href="../lectures/l-filesystems.html"> File systems: YAFFS </a>
	<ul>
	<li> dynamic vs. static wear leveling </li>
	<li> Block Lookup Table </li>
	<li> Flash Translation Layer (FTL) </li>
	<li> basics of a log-structured file system: all data, inode, and metadata changes are written as logs </li>
	<li> <em>I will not ask you about YAFFS2 vs. YAFFS1 </em> </li>
	<li> Know that for YAFFS the name space is reconstructed by traversing the log. </li>
	<li> Know that log entries that are no longer needed can get reused. </li>
	<li> Why is garbage collection needed? </li>
	<li> Purpose of checkpointing. </li>
	<li> Why a log-structured file system good for wear leveling? </li>
	</ul>
</li>

<li> <a href="../lectures/l-specialfs.html">Special devices and  file systems</a> 
	<ul>
	<li> Special devices: null device, zero device, random device </li>
	<li> Loop device: what is it? </li>
	<li> Special file systems: process file system (procfs), device file system (devfs), FUSE (user-level file system) </li>
	</ul>
</li>

<li> <a href="../lectures/l-net.html">Client-server networking</a> 
	<ul>
	<li> circuit-switched vs. packet switched networks </li>
	<li> protocols and layering </li>
	<li> OSI reference model: understand layers 1-4 (physical, data link, network, transport) </li>
	<li> terms: node, NIC, baseband vs. broadband </li>
	<li> I will not ask about media, hubs, routers, bridges, ethernet topology, or wireless networks <li>

	<li> transport address </li>
	<li> transport-layer protocols: connection-oriented (virtual circuit) vs. connetionless (datagram) </li>
	<li> Internet Protocol (IP) </li>
	<li> I will not ask about jumbo packets, MTUs, the structure of ethernet, IP, IPv6, TCP, or UDP packets.
		Understand, however, ethernet vs. IP addresses and that transport-layer IP protocols (TCP, UDP) have a port number. </li>
	<li> Packet encapsulation (enveloping) </li>
	<li> Address resolution protocol (what does it do and why do we need it?) </li>
	<li> I will not ask about routing </li>
	<li> TCP vs. UDP, port numbers and their purpose </li>
	</ul>
</li>

<li> <a href="../lectures/l-sockets.html">Sockets</a>
	<br/> <strong>New Text</strong>: <em> 3.6 (Communication in Client-Server Systems): 3.6.1 (Sockets); pages 136-138 </em>
	<br/> <strong>Old Text</strong>: <em> 3.6 (Communication in Client-Server Systems): 3.6.1 (Sockets); pages 126-129 </em>
        <ul>
	<li> Purpose of sockets
	<li>What do the following system calls do? <em>socket</em>, <em>bind</em>, <em>listen</em>, <em>connect</em></li>
	<li> I will not ask you about the parameters of the above functions </li>
	<li> I will not ask about synchronous vs. asynchronous operations </li>
	<li>System call interface: file descriptor-based and socket-specific</li>
	<li> What's the purpose of the socket layer and the <code>socket</code> structure? </li>
	<li>What's the purpose of a socket buffer (<tt>sk_buff</tt>)? </li>
	<li>I will not ask you about the <tt>socket</tt> or <tt>proto</tt> structures but know what a socket structure is used for vs. a sk_buff (socket buffer).</li>
	<li>What's the purpose of the abstract device interface layer?</li>
	<li>I will not ask about specific functions within the device interface (e.g., <em>dev_queue_xmit</em>, <em>netif_rx_schedule</em>)</li>
	<li>Understand where device drivers sit in the hierarchy.</li>
	<li>Linux NAPI approach to handling device interrupts </li>
	</ul>
</li>

<li> <a href="../lectures/l-rpc.html">Remote procedure calls</a> 
	<br/> <strong>New Text</strong>: <em> 3.6 (Communication in Client-Server Systems): 3.6.2 (Remote Procedure Calls); pages 138-142 </em>
	<br/> <strong>Old Text</strong>: <em> 3.6 (Communication in Client-Server Systems): 3.6.2 (Remote Procedure Calls); pages 129-132 </em>
	<ul>
	<li>Remote procedure call: definition/goal</li>
	<li> I will not ask you about the functional flow of regular procedure calls</li>
	<li> Language-level versus operating-system construct</li>
	<li>Stub functions: purpose of client and server stub functions</li>
	<li>RPC call flow</li>
	<li>I will not ask about big vs. little endian or data representation formats</li>
	<li>I will not ask about implicit vs. explicit typing, where to bind, transport protocols, or security issues</li>
	<li>Understand the need for an interface definition language (IDL)</li>
	</ul>
</li>

<li> <a href="../lectures/l-nfs.html">Network file systems</a> 
	<br/> <strong>New Text</strong>: <em> 11.8 (NFS) pages 545-551 </em>
	<ul>
	<li> Network attached storage (NAS): definition </li>
	<li> upload/download model vs. remote access model </li>
	<li> sequential vs. session semantics </li>
	<li> I will not ask about immutable files, atomic transactions, or file usage patterns </li>
	<li> Understand stateful vs. stateless approaches </li>
	<li> understand what write-through caches, read-ahead, and delayed writes do </li>
	<li> NFS 
		<ul>
		<li> I will not ask about design goals </li>
		<li> Understand that an RPC interface is used </li>
		<li> Purpose of mounting vs. directory &amp; file access protocols </li>
		<li> What does the <em>lookup</em> RPC do and why is it not an <em>open</em> of a file ? </li>
		<li> Do not memorize the NFS RPC functions but have an idea of what they do. </li>
		<li> Validation as an approach to cache management </li>
		<li> Read-ahead to improve performance </li>
		<li> Don't memorize the list of problems with NFS but go through them and understand them </li>
		<li> Why does locking not work? Why can open with append not be guaranteed to work? </li>
		</ul>
	</li>
	
	<li> AFS 
		<ul>
		<li> Design goals </li>
		<li> Big ideas: whole file serving and whole file caching </li>
		<li> I will not ask about cells, volumes, the cell directory server, or the Volume Location Database </li>
		<li> callback promise </li>
		<li> session semantics </li>
		</ul>
	</li>
	
	<li> SMB/CIFS 
		<ul>
		<li> Design goals </li>
		<li> message blocks  </li>
		<li> remote access protocol </li>
		<li> I will not ask about the structure of the message block </li>
		<li> Don't memorize the list of commands but they should make sense </li>
		<li> Understand the things you can do with SMB that you cannot do with NFS because SMB is stateful (delete on the server won't cause a remotely open file to disappear, lock a file, open with append: all these require state) </li>
		<li> I will not ask about the protocol but note that it's connection-oriented </li>
		</ul>
	</li>
	</ul>
</li>

<li> <a href="../lectures/l-protection.html">Protection  </a>
	<br/> <strong>New Text</strong>: <em> 13 (Protection) - 13.3.2 (An Example: UNIX) pages 601-606. </em>
	<br/> <strong>New Text</strong>: <em> 13.4 (Access Matrix) - 13.5.3 (Capability Lists) pages 608-613. </em>
	<br/> <strong>New Text</strong>: <em> 13.6 (Access Control) - 13.7 (Revocation) pages 615-616. </em>
	<br/> <strong>Old Text</strong>: <em> Sections 13-13.3.2, 13.4-13.5.3, 13.6-13.7  pages 529-534, 536-541, 543-545 </em>
	<ul>
	<li> Principle of least privilege </li>
	<li> Privilege separation </li>
	<li> setuid </li>
	<li> Protection domain, access matrix </li>
	<li> I will not ask about domain transfers, copy, owner, and control operations </li>
	<li> Access control list vs. capability list </li>
	<li> Limited ACLs in POSIX systems vs. full ACLs </li>
	<li> Discretionary access control (DAC) vs. mandatory access control (MAC) </li>
	<li> What does the Bell-LaPadula model do? </li>
	</ul>
</li>


<li> <a href="../lectures/l-security.html">Security  </a>
	<br/> <strong>New Text</strong>: <em> 14 (Security) - 13.3.3 (Denial of Service) pages 633-650. </em>
	<br/> <strong>Old Text</strong>: <em> Sections 14 to 14.3.3, pages 553-570. </em>
	<ul>
	<li> I will not ask you to list threats, discuss attack categories or techniques </li>
	<li> Buffer overflow bug: stack smashing </li>
	<li> Return Oriented Programming </li>
	<li> Address Space Layout Randomization </li>
	<li> Stack canaries </li>
	<li> I will not ask about network service penetration or SYN flooding </li>
	<li> What's a virus?  </li>
	<li> What's a rootkit? </li>
	<li> sandboxing 
		<ul>
		<li> chroot jail </li>
		<li> Kernel-level sandboxing: understand that it provides policy-based access control </li>
		<li> What is the Java sandbox </li>
		</ul>
	</ul>
	</li>
</li>

<li> <a href="../lectures/l-crypto.html">Cryptographic systems </a>
	<br/> <strong>New Text</strong>: <em> 14.4 (Cryptography as a Security Tool) - 14.4.1 (Encryption) pages 650-657. </em>
	<br/> <strong>Old Text</strong>: <em> 14.4 (Cryptography as a Security Tool) - 14.4.1 (Encryption) pages 570-578. </em>
	<ul>
	<li> restricted vs. symmetric vs. public key algorithms </li>
	<li> use of a hash function </li>
	<li> key length vs. difficulty of brute-force attack </li>
	<li> understand the difference between public key and symmetric algorithms;
		what private keys are used for, what public keys are used for. </li>
        <li> key exchange (using Diffie-Hellman, and public Keys)
		<ul>
			<li> Diffie-Hellman (know what it does but don't memorize the algorithm) </li>
                	<li> public key cryptography (how do you use it for key exchange?) </li>
		</ul>
	</li>
	<li> how do you use public keys for encryption, signatures, and key exchange? </li>
	<li> do not memorize algorithms:
                        I will not ask you to recite the RSA or Diffie-Hellman
                        algorithms. You should know that Diffie-Hellman is a key exchange algorithm
			and that RSA is a public-key algorithm.
	</li>
	<li> hybrid cryptosystem (understand advantage and how session key exchange works) </li>
	<li> digital signatures with public key algorithms </li>
	<li> secure communciation 
		<ul>
		<li> with symmetric cryptography </li>
		<li> with public key cryptography </li>
		<li> with a hybrid cryptosystem </li>
		</ul>
	</li>
	</ul>
</li>

<li> <a href="../lectures/l-auth.html">Authentication </a>
	<br/> <strong>New Text</strong>: <em> 14.5 (User Authentication) - 14.7 (Firewalling) pages 661-674. </em>
	<br/> <strong>Old Text</strong>: <em> 14.5 (User Authentication) - 14.7 (Firewalling) pages 581-588. </em>
	<ul>
	<li> Authentication vs. Identification </li>
	<li> multi-factor authentication 
		<ul>
		<li> what are the three factors? </li>
		</ul>
	</li>
	<li> reusable passwords (PAP, password authentication protocol) </li>
	<li> dictionary attacks, hash
	<li> Challenge Handshake Authentication Protocol (CHAP) </li>
	<li> one-time passwords: SecurID (just know that the password is <em>f(PIN, seed, time)</em>)  </li>

	<li> public key authentication 
		<ul>
		<li> how does it work? What is a nonce and how do you use it? </li>
		<li> digital certificates (don't memorize fields but understand how a certificate can be used) </li>
		</ul>
	</li>
	<li> signed software: page-based vs. whole-code signatures (remember how signatures are created) </li>
	</ul>
</li>

<li> <a href="../lectures/l-vm.html">Virtualization</a> </li>
	<ul>
	<li> Types of virtualization: memory, CPU, storage, machine </li>
	<li> Processor (CPU) virtualization vs. machine virtualization </li>
	<li> Virtual Machine Monitor, hypervisor </li>
	<li> how do  privileged instructions work under a MM? Trap into hypervisor. </li>
	<li> Hosted VM vs. Native VM </li>
	<li> Native VM architecture requires the VMM to do scheduling of the virtual machines under it </li>
	<li> You do not have to know the architectural support in Intel and AMD architectures
	but you should understand that they can create an exit from a VMM that allows software (the OS under
	the VM) to feel like an interrupt took place </li>
	<li> I will not ask you about scheduling VMs </li>
	<li> What is OS-level virtualization? </li>
	</ul>

</ul>
-->

</div> <!-- main -->

<div id="footer">
<hr/>
<style type="text/css">  
span.codedirection { unicode-bidi:bidi-override; direction: rtl; }  
</style>  

<p> &copy; 2003-2019 Paul Krzyzanowski. All rights reserved.</p>
<p>For questions or comments about this site, contact Paul Krzyzanowski, 
<span class="codedirection">gro.kp@ofnibew</span>
</p>
<p>
The entire contents of this site are protected by copyright under national and international law.
No part of this site may be copied, reproduced, stored in a retrieval system, or transmitted, in any form,
or by any means whether electronic, mechanical or otherwise without the prior written
consent of the copyright holder.
If there is something on this page that you want to use, please let me know.
</p>
<p>
Any opinions expressed on this page do not necessarily reflect the opinions of my employers and may not
even reflect my own.
</p>
<p> Last updated: February 14, 2019
</p>
<img class="stamp" src="../..//css/images/recycled_pixels_logo.png" alt="recycled pixels" height="80" width="80" />
</div> <!-- footer -->
<div id="tear">
</div>


<div id="sidebar1">
<h1 class="first">Contents </h1>
	<h2> CS 416 </h2>
	<ul>
	<li> <a href="../index.html"> Main course page </a> </li>
	<li> <a href="../news.html"> News </a> </li>
	<li> <a href="../syllabus.html"> Syllabus </a> </li>
	<li> <a href="../hw/index.html"> Homework </a> </li>
	<li> <a href="../notes/index.html"> Documents </a> </li>
	<li> <a href="../exam/index.html"> Exam info </a> </li>
	<li> <a href="../grades/index.html"> Check your grades </a> </li>
	<li> <a href="https://sakai.rutgers.edu/portal"> Sakai </a> </li>
	</ul>

	<h2> CS 416 background </h2>
	<ul>
	<li> <a href="../about.html"> About the course </a> </li>
	<li> <a href="../prereq.html"> Prerequisites </a> </li>
	<li> <a href="../things.html"> Things you need </a> </li>
	<li> <a href="../policy.html"> Policy  </a> </li>
	</ul>

	<h2> Exam Info </h2>
	<ul>
	<li> <a href="../exam/index.html#list">List of topics</a>
	<li> <a href="../exam/old/index.html"> Old Exams </a> </li>
	<li> <a href="../exam/study-guide-1.html"> Exam 1 Study Guide </a> </li>
	<li> <a href="../exam/study-guide-2.html"> Exam 2 Study Guide </a> </li>
	<li> <a href="../exam/study-guide-3.html"> Exam 3 Study Guide </a> </li>
	<li> <a href="../exam/study-guide-final.html"> Final Study Guide </a> </li>
	</ul>
	
</div>

<div id="sidebar2">
<!--
<h1 class="first"> Free junk </h1>
<p>
Tedst
</p>
<hr/>
<ul>
<li> List item
</ul>
-->
</div>

</div>
</div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-8293152-1");
pageTracker._trackPageview();
} catch(err) {}</script>

</body>
</html>
