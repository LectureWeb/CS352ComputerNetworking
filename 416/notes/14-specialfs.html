<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title> Special File Systems </title>
<link href="../../css/layout.css" rel="stylesheet" type="text/css" />
<link href="../../css/main.css" rel="stylesheet" type="text/css" />
<link href="../../css/print.css" rel="stylesheet" type="text/css" media="print" />
<link href="../../css/main-print.css" rel="stylesheet" type="text/css" media="print" />
<style type="text/css">

#main table.doclist {
	width: 80%;
}
#main .doclist .date, #main .doclist .item {
        vertical-align: baseline; /* for opera */
}
#main .doclist tr {
        vertical-align: baseline;
}
#main .doclist th.item {
        text-align: left;
}
#main .doclist td.item {
        text-align: left;
}
#main a.linksign:link, #main a.linksign:visited, #main a.linksign a:hover {
        text-decoration: none;
}

</style>
</head>
<body id="s_ru416">
<div id="wrapper">
<!-- _______________________________________ BANNER _______________________________________ -->
<div id="banner">
  <div id="logo">
  <img src="../../css/images/pk-org-pencil.png" alt="pk.org" name="logo" width="122" height="45"/>
  </div>
  <div id="title"> Operating Systems </div>
  <div id="search">
  <form method="get" action="http://www.google.com/search">
	<div style="border:none ;padding:2px;width:25em;">
	<input type="text" name="q" size="25" maxlength="255" value="" />
	<input type="submit" value="Search" />
	<input type="hidden"  name="sitesearch" value="www.pk.org" checked />
	</div>
  </form>
  </div>
  <ul>
    <li class="separator"><a href="../../about/index.html">About</a></li>
    <li class="separator"><a href="../../about/contact.html">Contact</a></li>
    <li><a href="../../sitemap.html">Site map</a></li>
  </ul>
</div>

<!-- _______________________________________ MAIN NAV _______________________________________ -->
<div id="navbar">
	<ul>
	<li class="homelink"><a href="../../index.html">Home</a></li>
<!--
	<li class="aboutlink"><a href="../../about/index.html">About</a></li>
-->
	<li class="ru"><a href="../../rutgers/index.html">Rutgers</a></li>
	<li class="ru352"><a href="../../352/index.html">Internet Technology [352]</a></li>
	<li class="ru416"><a href="../../416/index.html">Operating Systems [416]</a></li>
	<li class="ru417"><a href="../../417/index.html">Distributed Systems [417]</a></li>
	<li class="ru419"><a href="../../419/index.html">Computer Security [419]</a></li>
	<li class="cslink"><a href="../../cs/index.html">Computing</a></li>
	<li class="photolink"><a href="../../photo/index.html">Photography</a></li>
<!--
	<li class="funlink"><a href="#">Coming</a></li>
	<li class="funlink"><a href="#">Soon</a></li>
-->
	</ul>
</div>

<div id="subnav">
<p>
You are in: 
</p>
<ul>
	<li class="first"> <a href="index.html"> Home </a> 
 	<li> <a href="../../rutgers/index.html"> Rutgers </a> 
 	<li> <a href="../index.html"> CS 416 </a> 
 	<li> <a href="../notes/index.html"> Documents </a> 
 	<li> <a href="../notes/14-specialfs.html"> Special File Systems </a> 
</ul>
</div>
<div id="content-wrapper">
<div id="main">
<div id="headline">
<h1> Special Devices and File Systems </h1>

<p class="author"> Paul Krzyzanowski </p>
<p class="date"> last update: March 22, 2012 </p>
</div>


<h1> Introduction </h1>
<p>
In older operating systems, kernel file structures referenced the underlying file system
directly. For example, a UNIX operating system would have its file entry reference inodes
within the file system. As operating systems had to support different file system types,
that direct approach no longer worked. As we have seen, a layer of abstraction, called
the Virtual File System (VFS), was created to provide a separation between generic file operations
and the implementation that is specific to a particular file system. This architecture
allowed file system types to become modular components that could be added on the fly, with
the module's initialization function registering the software as a file system.
</p>
<p>
VFS enabled a single operating system to support multiple file system types. For
example, a Linux system may have a disk formatted with an ext4 file system and still
access a UDF-formatted DVD (also known as ISO 13346, 
<a href="http://en.wikipedia.org/wiki/Universal_Disk_Format">Universal Disk format</a>)
as well as a FAT-32 file system on an SDHC flash memory card. VFS also enabled network file systems,
where the network file system module makes requessts to a remote server.
</p>
<p>
What the VFS architecture also enabled is the ability to easily create file system modules for
things that aren't traditionally viewed as file systems. We tend to think of file systems
as components that present us with the ability to manage a hierarchy of named objects (files)
whose contents we can create, modify, and delete. However, these objects need not be
traditional files sitting on disks (or flash memory). The contents of files and even the
names and directories themselves can be dynamically created by the file system module. For
example, a <em>process file system</em> can provide you with a file system view of the
processes on a system and the ability to get, and in some cases change, the state of any
process. We refer to these non-standard file systems as <em>special file systems</em>.
</p>
<p>
Why do this?  One of the great things about
a hierarchical file system is its name space. We intuitively understand the concept of
directories, subdirectories, and files. We can browse directories and open files through
graphical interfaces, the command line, shell scripts, and with just about any programming
or scripting language. We don't need to rely on knowledge of arcane system calls. More
importantly, with a file system interface, we may not even need to create specialized 
system calls. Why do you need a system call to get the current time when you can 
just open and read <tt>/dev/time</tt>?
</p>


<h1> Pseudo devices </h1>
<p>
While we've been talking about file systems, devices also need not refer to physical
devices. Given that a device driver is a module containing a bunch of code that implements
what <em>read</em> and <em>write</em> operations to the "device" mean,
we can have it do just about any processing.
</p>
<h2> Null device </h2>
<p>
The simplest of these is the 
<strong>null device</strong>. It is known as <tt>/dev/null</tt> on Unix systems, 
<tt>\Device\Null</tt> on Windows NT and derivatives, and <tt>NUL</tt> on earlier Windows systems.
It is also sometimes referred to as a <strong>bit bucket</strong>.
The null device is simply a character device that discards
any input given to and report and end-of-file whenever a process tries to read from it.
</p>

<h2> Zero device </h2>
<p>
The <strong>zero device</strong> is a simple variation of the null device that, instead of
returning an end-of-file, returns an unlimited number bytes whose value is 0.
</p>
<p>
On POSIX systems, it is located in <tt>/dev/zero</tt>. One common use of it is to create
a file of a certain size containing nothing but zeros. For example, the command:
</p>
<pre>
dd if=/dev/zero of=nothing bs=1024 count=1024
</pre>
<p>
Creates a 1 MB file (block size=1024 &times; count=1024) named <tt>nothing</tt>
filled with zero-value bytes.
</p>

<h2> Random device </h2>
<p>
The <strong>random device</strong> is a character device that returns an endless
stream of random numbers (bytes). Depending on the operating system and the implementation
of the driver, the driver will either use a pseudorandom number generator or 
provide a high-quality cryptographically secure sequence of random numbers gathered from
entropy obtained in various observed events in the system. Most POSIX systems contain
two device files: <tt>/dev/random</tt> and <tt>/dev/urandom</tt>. The first is intended
for high-quality cryptographically strong random numberes. However, read operations
may block until a sufficient amount of events in the system envrionbment are processed to build up large
entropy values. The second device, <tt>/dev/urandom</tt>, is non-blocking and may
produce more pseudorandom data when collected entropy levels are low.
</p>

<h2> The loop device </h2>
<p>
The <strong>loop device</strong> is not a file system. It is a device driver that
makes a regular file accessible just like a block device.
One associates a specific file with a specific loop device.
On Linux, these devices are 
typically presented with names such as <tt>/dev/loop0</tt>, <tt>/dev/loop1</tt>, etc.
The loop device is a block device
and provides interfaces to read and write fixed-sized blocks of data. These block
read/write requests are transformed by the loop driver into the appropriate 
read/write requests to the underlying file. 
</p>
<div class="figure width300"> <img width="300" height="218" src="images/12a-loop.png"/>
Loop driver
</div>
<p>
The reason this is useful is that file systems are built on top of block devices.
With the loop driver, we can give any file a block device interface and then construct
a file system within the file. The common uses for this are to create and access CD or
DVD disk images (that may then be burned onto a real disk), distribute software in a
way that provides the illusion that it came on a disk image, and also to create
encrypted file systems. For this latter case, the loop driver itself often supports
encryption so that any file system built on that file will get each data block encrypted
and decrypted by the loop driver. Alternatively, one can format a file system that supports
encryption onto the file. In either case, this loop device can then be
 mounted anywhere in the hierarchical name space and that mounted directory can
be used for secure storage needs even if the native system fils system is not encrypted.
</p>
<p>
On Linux, the association between the loop device and file is made
via the <tt>losetup</tt> command, which opens the given loop device and
uses an <em>ioctl</em> system call to send it the name of the file that
it should use.
</p>

<p>
Here's a basic example of using the loop device on Linux:
</p>
<ol class="separated">
<li>
<p>Create a 10 MB file named <tt>file.img</tt>:
</p>
<pre>
# dd if=/dev/zero of=file.img bs=1k count=10000
10000+0 records in
10000+0 records out
</pre>
</li>

<li>
<p>
Associate the loop device <tt>/dev/loop0</tt> with the file <tt>file.img</tt>:
</p>
<pre>
# losetup /dev/loop0 file.img
</pre>
</li>

<li>
<p>
Create an ext2 file system on this loop device (and hence, on <tt>file.img</tt>):
</p>
<pre>
mke2fs -c /dev/loop0 10000  	
mke2fs 1.41.12 (17-May-2010)
Filesystem label=
OS type: Linux
Block size=1024 (log=0)
Fragment size=1024 (log=0)
Stride=0 blocks, Stripe width=0 blocks
...
</pre>
</li>

<li>
<p>
We now have a file system. Mount it into our name space at <tt>/mnt/here</tt>.
</p>
<pre>
# mkdir /mnt/here
# mount -t ext2 /dev/loop0 /mnt/here
</pre>
</li>

<li> Now we can create and access files and directories under <tt>/mnt/here</tt>
and they will all be stored within the file system formatted within the file <tt>file.img</tt>.
</li>
</ol>

<h1> Special File Systems </h1>

<h2> Process file system</h2>
<p>
The process file system was first created by Tom Killian for the 8th Edition of 
UNIX. [Versions of UNIX developed in the Computer Science Research Center at Bell
Labs were named after the editions of their manuals given that the system was in a
continual state of evolution.] It was then considerably refined under in
the Plan 9 operating system and given a hierarchy of files per process.
Plan 9 was written in part by some of the authors of the original UNIX operating system
with an eye to use the things that worked well and dump the rest. One of the things that
worked well was the "everything is a file" view of the world. 
</p>
<p>
The process file system (also called <em>procfs</em> or <em>proc file system</em>) 
presents a file system name space view of processes and other system information.
Under Plan 9, Solaris, and Linux, each process is presented as a directory whose
name is the process ID number underneath the mount point <tt>/proc</tt>. 
Within each process directory, one can read information about the process.
For example, <tt>cwd</tt> is a symbolic link to the process' current
directory; <tt>cmdline</tt> is a file that contains the command line used to 
run the process; <tt>stack</tt> is the call stack of the process; <tt>pagemap</tt>
contains the page table information for the process; <tt>status</tt> contains
status about the process, such as signal maps and context switch counts.
</p>
<p>
All these files and directories are created dynamically on demand (when accessed). No
aspect of the process file system exists in a disk-based file system. procfs is 
a file system driver that registers itself with VFS and is mounted under <tt>/proc</tt> on
the top-level file system. Whenever VFS makes a request to get inodes for files
and direcotires, procfs creates them from information it gets by probing various
kernel structures, such as the process control block.
</p>
<p>
In addition to information about processes, procfs has become a conduit to a wide
set of information about the running kernel. For example (just a small list):
</p>
<ul>
<li> <tt>/proc/devices</tt>: enumerates all registered character and block devices.</li>
<li> <tt>/proc/cpuinfo</tt>: information about the cpu</li>
<li> <tt>/proc/devices</tt>:  list of all registered character and block devices</li>
<li> <tt>/proc/diskstats</tt>: information about logical disks</li>
<li> <tt>/proc/meminfo</tt>: information about system and kernel memory</li>
<li> <tt>/proc/net</tt>: directory containing information about the network protocl stack</li>
<li> <tt>/proc/swaps</tt>: list of swap partitions</li>
<li> <tt>/proc/uptime</tt>: time the system has been up</li>
<li> <tt>/proc/version</tt>: kernel version</li>
</ul>
<p>
This interface provides a richer set of data than is often obtainable through system
calls and makes it easier to get this data through file browsing or scripting as 
well as dedicated programs.
</p>

<h2> Device file system </h2>
<p>
One issue with devices under POSIX systems is that they could be located only by
name and the names were present in a regular file system (e.g., root disk) as 
special device files. These files were created with the <em>mknod</em> command (which
uses a system call by the same name) and contained metadata in the inode that
identified them as character or block files. The metadata of the file also identified
the major and minor numbers of the corresponding device.
This worked well until devices became more dynamic. When bus controllers discovered
new devices, such as USB-connected disk drives, we needed to be able to create and delete
device files as those devices were discovered or were no longer connected.
</p>
<p>
One approach to this was to replace the tradition of creating special files in the
<tt>/dev</tt> directory and instead create a special-purpose file system, <strong>devfs</strong>
that is mounted on <tt>/dev</tt> and presents a file system view of all the devices
registed in the kernel. Essentially, it is a view into the kernel's character and block device tables.
</p>
<p>
The <tt>devfs</tt> file system is still present in Apple's OS X and other systems.
It has been evicted from Linux as of the 2.6 kernel and replaced with a <tt>udev</tt>
device manager. This device manager is a user-level process that gets a list of
existing devices from the kernel and then reads device creation and removal events from
the kernel. The <a href="http://www.kernel.org/pub/linux/utils/kernel/hotplug/udev/udev.html">udev manager</a> supports a rich set of rules for creating and deleting device files based on events.
</p>


<h2> FUSE: User-level file system </h2>

<p>
The last example of a special purpose file system that we will look at isn't really
a file system but rather a framework for file systems. FUSE is a file system
module that allows one to create file systems in user space. 
FUSE contains three parts:
</p>
<ol>
<li>
The FUSE kernel module: This module registers itself as a file file system with VFS.
It serves an a conduit between VFS requests and the user-level interpretation of them.
</li>
<li>
A userspace library (libfuse): This library contains support functions
to allow the user file system daemon to interface with the FUSE protocol.
</li>

<li>
A mount utility (fusermount): Mounting file systems requires administrative 
privileges. Fusermount is a helper program that is installed setuid root.
This means that it runs with administrative privileges whenever any user runs it.
It allows an ordinary user to create a directory that will serve as a mount
point for their user-level file system and mount it via fusermount.
The mount starts a file system daemon process (background process) that
is run with the user's privileges and in interprets all file system operations
that it receives from the kernel module. It communicates with the kernel 
module via a file descriptor it obtained by opening <tt>/dev/fuse</tt>.
</li>
</ol>






<h1> References </h1>

<ul>
<li> <a href="<a href="http://www.freebsd.org/doc/en/books/design-44bsd/">The Design and Implementation of the 4.4BSD Operating System</a>,
Marshall Kirk McKusick,
Keith Bostic,
Michael J. Karels,
John S. QuartermanA. &copy;1996 Addison-Wesley Longman, Inc.
</li>

<li> <a href="http://en.wikipedia.org/wiki//dev/random">/dev/random</a>, Wikipedia article.
</li>

<li> <a href="http://en.wikipedia.org/wiki/Loop_device">Loop device</a>, Wikipedia article.

<li> <a href="http://doc.cat-v.org/plan_9/1st_edition/designing_plan_9">Bell Labs' Plan 9 research project looks to tomorrow</a>,
Rob Pike, Dave Presotto, Ken Thompson, and Howard Trickey. UKUUG Conference in London, July 1990.
</li>

<li> <a href="http://www.kernel.org/pub/linux/utils/kernel/hotplug/udev/udev.html">udev: Linux
dynamic device management</a>, kernel.org documentation.
</li>

<li> <a href="http://free-electrons.com/doc/udev.pdf">Hotplugging with udev</a>,
Michael Opdenacker. Free Electrons, &copy; 2004-2009.

<li> <a href="http://fuse.sourceforge.net/">FUSE: Filesystem in Userspace</a>, Sourcceforge.net.
</ul>

</div>
<div id="footer">
<hr/>
<style type="text/css">  
span.codedirection { unicode-bidi:bidi-override; direction: rtl; }  
</style>  

<p> &copy; 2003-2019 Paul Krzyzanowski. All rights reserved.</p>
<p>For questions or comments about this site, contact Paul Krzyzanowski, 
<span class="codedirection">gro.kp@ofnibew</span>
</p>
<p>
The entire contents of this site are protected by copyright under national and international law.
No part of this site may be copied, reproduced, stored in a retrieval system, or transmitted, in any form,
or by any means whether electronic, mechanical or otherwise without the prior written
consent of the copyright holder.
If there is something on this page that you want to use, please let me know.
</p>
<p>
Any opinions expressed on this page do not necessarily reflect the opinions of my employers and may not
even reflect my own.
</p>
<p> Last updated: February 14, 2019
</p>
<img class="stamp" src="../..//css/images/recycled_pixels_logo.png" alt="recycled pixels" height="80" width="80" />
</div> <!-- footer -->
<div id="tear">
</div>


<div id="sidebar1">
<h1 class="first">Contents </h1>
	<h2> CS 416 </h2>
	<ul>
	<li> <a href="../index.html"> Main course page </a> </li>
	<li> <a href="../news.html"> News </a> </li>
	<li> <a href="../syllabus.html"> Syllabus </a> </li>
	<li> <a href="../hw/index.html"> Homework </a> </li>
	<li> <a href="../notes/index.html"> Documents </a> </li>
	<li> <a href="../exam/index.html"> Exam info </a> </li>
	<li> <a href="../grades/index.html"> Check your grades </a> </li>
	<li> <a href="https://sakai.rutgers.edu/portal"> Sakai </a> </li>
	</ul>

	<h2> CS 416 background </h2>
	<ul>
	<li> <a href="../about.html"> About the course </a> </li>
	<li> <a href="../prereq.html"> Prerequisites </a> </li>
	<li> <a href="../things.html"> Things you need </a> </li>
	<li> <a href="../policy.html"> Policy  </a> </li>
	</ul>
</div>

<div id="sidebar2">
<!--
<h1 class="first"> Free junk </h1>
<p>
Tedst
</p>
<hr/>
<ul>
<li> List item
</ul>
-->
</div>

</div>
</div>
</body>
</html>
